{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/ruitai/alpaca/frontend/src/Components/stream.js\";\nimport React, { Component } from \"react\";\n\nclass Stream extends Component {\n  constructor(props) {\n    super(props);\n    this.ws = new WebSocket('wss://data.alpaca.markets/stream');\n    this.state = {\n      key_id: props.key_id,\n      secret_key: props.secret_key,\n      ticker: props.ticker\n    };\n  } // instance of websocket connection as a class property\n\n\n  componentDidMount() {\n    this.ws.onopen = () => {\n      // on connecting, do nothing but log it to the console\n      console.log('connected');\n      let auth_data = {\n        \"action\": \"authenticate\",\n        \"data\": {\n          \"key_id\": this.state.key_id,\n          \"secret_key\": this.state.secret_key\n        }\n      };\n      this.ws.send(JSON.stringify(auth_data)); //Make this generic\n\n      let listen_message = {\n        \"action\": \"listen\",\n        \"data\": {\n          \"streams\": [\"T.\" + this.state.ticker]\n        }\n      };\n      this.ws.send(JSON.stringify(listen_message));\n    };\n\n    this.ws.onmessage = evt => {\n      //TODO: Test tomorrow, but it seems this returns a JSON string\n      //message parses it back into a dict-type of thing, with keys that you can then read off of\n      this.setState({\n        dataFromServer: JSON.parse(evt.data)\n      });\n      console.log(JSON.parse(evt.data));\n    };\n\n    this.ws.onclose = () => {\n      console.log('disconnected'); // automatically try to reconnect on connection loss\n    };\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"button\", {\n      children: this.state.dataFromServer[\"p\"]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 16\n    }, this);\n  }\n\n}\n\nexport default Stream;","map":{"version":3,"sources":["/home/ruitai/alpaca/frontend/src/Components/stream.js"],"names":["React","Component","Stream","constructor","props","ws","WebSocket","state","key_id","secret_key","ticker","componentDidMount","onopen","console","log","auth_data","send","JSON","stringify","listen_message","onmessage","evt","setState","dataFromServer","parse","data","onclose","render"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAgC,OAAhC;;AAEA,MAAMC,MAAN,SAAqBD,SAArB,CAA+B;AAC3BE,EAAAA,WAAW,CAACC,KAAD,EAAO;AACd,UAAMA,KAAN;AADc,SAUlBC,EAVkB,GAUb,IAAIC,SAAJ,CAAc,kCAAd,CAVa;AAEd,SAAKC,KAAL,GAAa;AACTC,MAAAA,MAAM,EAAEJ,KAAK,CAACI,MADL;AAETC,MAAAA,UAAU,EAAEL,KAAK,CAACK,UAFT;AAGTC,MAAAA,MAAM,EAAEN,KAAK,CAACM;AAHL,KAAb;AAKH,GAR0B,CAU3B;;;AAGAC,EAAAA,iBAAiB,GAAG;AAChB,SAAKN,EAAL,CAAQO,MAAR,GAAiB,MAAM;AACvB;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACA,UAAIC,SAAS,GAAG;AACZ,kBAAU,cADE;AAEZ,gBAAQ;AAAC,oBAAU,KAAKR,KAAL,CAAWC,MAAtB;AAA8B,wBAAc,KAAKD,KAAL,CAAWE;AAAvD;AAFI,OAAhB;AAKA,WAAKJ,EAAL,CAAQW,IAAR,CAAaC,IAAI,CAACC,SAAL,CAAeH,SAAf,CAAb,EARuB,CAUvB;;AACA,UAAII,cAAc,GAAG;AAAC,kBAAU,QAAX;AAAqB,gBAAQ;AAAC,qBAAW,CAAC,OAAK,KAAKZ,KAAL,CAAWG,MAAjB;AAAZ;AAA7B,OAArB;AAEA,WAAKL,EAAL,CAAQW,IAAR,CAAaC,IAAI,CAACC,SAAL,CAAeC,cAAf,CAAb;AAGC,KAhBD;;AAkBA,SAAKd,EAAL,CAAQe,SAAR,GAAoBC,GAAG,IAAI;AAE3B;AACA;AACA,WAAKC,QAAL,CAAc;AAACC,QAAAA,cAAc,EAAEN,IAAI,CAACO,KAAL,CAAWH,GAAG,CAACI,IAAf;AAAjB,OAAd;AACAZ,MAAAA,OAAO,CAACC,GAAR,CAAYG,IAAI,CAACO,KAAL,CAAWH,GAAG,CAACI,IAAf,CAAZ;AACC,KAND;;AAQA,SAAKpB,EAAL,CAAQqB,OAAR,GAAkB,MAAM;AACxBb,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EADwB,CAExB;AAEC,KAJD;AAMH;;AAEDa,EAAAA,MAAM,GAAE;AACJ,wBAAO;AAAA,gBAAS,KAAKpB,KAAL,CAAWgB,cAAX,CAA0B,GAA1B;AAAT;AAAA;AAAA;AAAA;AAAA,YAAP;AACH;;AAlD0B;;AAqD/B,eAAerB,MAAf","sourcesContent":["import React, { Component }from \"react\";\n\nclass Stream extends Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            key_id: props.key_id,\n            secret_key: props.secret_key,\n            ticker: props.ticker,\n        }\n    }\n\n    // instance of websocket connection as a class property\n    ws = new WebSocket('wss://data.alpaca.markets/stream')\n\n    componentDidMount() {\n        this.ws.onopen = () => {\n        // on connecting, do nothing but log it to the console\n        console.log('connected')\n        let auth_data = {\n            \"action\": \"authenticate\",\n            \"data\": {\"key_id\": this.state.key_id, \"secret_key\": this.state.secret_key}\n        }\n    \n        this.ws.send(JSON.stringify(auth_data))\n\n        //Make this generic\n        let listen_message = {\"action\": \"listen\", \"data\": {\"streams\": [\"T.\"+this.state.ticker]}}\n\n        this.ws.send(JSON.stringify(listen_message))            \n\n\n        }\n\n        this.ws.onmessage = evt => {\n\n        //TODO: Test tomorrow, but it seems this returns a JSON string\n        //message parses it back into a dict-type of thing, with keys that you can then read off of\n        this.setState({dataFromServer: JSON.parse(evt.data)})\n        console.log(JSON.parse(evt.data))\n        }\n\n        this.ws.onclose = () => {\n        console.log('disconnected')\n        // automatically try to reconnect on connection loss\n\n        }\n\n    }\n\n    render(){\n        return(<button>{this.state.dataFromServer[\"p\"]}</button>)\n    }\n}\n\nexport default Stream;"]},"metadata":{},"sourceType":"module"}